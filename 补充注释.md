# 电力系统拓扑在仿真程序中的工作原理分析 (以ABC串联线路为例)

本文档将详细分析提供的C++代码中，电力系统（以ABC串联线路为例）的拓扑结构是如何被建模、初始化，以及如何在保护逻辑仿真中被利用的。

## 核心概念

程序基于以下几个核心概念：

1.  **ECS (Entity-Component-System - 实体组件系统):**
    *   **实体 (Entity):** 唯一的ID (`Entity`类型，`uint64_t`)，代表仿真世界中的一个对象（如线路A、断路器B）。
    *   **组件 (Component):** 纯数据结构，存储实体的状态和属性（如 `LineIdentityComponent` 存储线路名称、上下游连接；`BreakerStateComponent` 存储断路器开关状态）。实体本身没有数据或行为，其特性由附加的组件定义。所有组件继承自 `IComponent`。
    *   **系统 (System):** 处理具有特定组件组合的实体的逻辑。在本例中，`LogicProtectionSystem` 类及其内部的协程任务 (如 `protection_device_logic_task` 和 `breaker_logic_task`) 扮演了系统的角色，实现了保护和断路器的行为逻辑。
    *   **注册表 (Registry):** `Registry` 类是ECS的核心，负责创建实体、为实体添加/获取组件，并管理所有实体及其组件的存储。

2.  **协程 (Coroutines):**
    *   使用自定义的 `cps_coro` 库 (`cps_coro::Task`, `cps_coro::Scheduler`) 实现轻量级的协作式多任务处理。
    *   每个保护装置和断路器都拥有自己的协程任务，这些任务可以独立运行、等待特定事件或延迟一段时间。
    *   关键协程操作：
        *   `co_await cps_coro::delay(duration)`: 协程暂停指定时间。
        *   `co_await cps_coro::wait_for_event<EventType>(event_id)`: 协程暂停，等待特定事件发生，并可接收事件数据。
        *   `scheduler_.trigger_event(event_id, data)`: 触发一个事件，可能会唤醒等待该事件的协程。

3.  **事件驱动仿真 (Event-Driven Simulation):**
    *   仿真过程由离散的事件（如故障发生、断路器跳闸命令、断路器状态改变）来驱动。
    *   调度器 (`scheduler_instance`) 管理仿真时间 (`current_time_`)，并根据事件的发生和任务的延时来调度和执行各个协程任务。

## ABC串联线路拓拓扑的表示与初始化

在 `LogicProtectionSystem::initialize_scenario_entities()` 函数中，ABC串联线路的拓扑结构被建立起来。

### 1. 线路和断路器实体的创建

*   程序创建了三个线路实体: `line_A_entity`, `line_B_entity`, `line_C_entity`。
*   程序创建了三个断路器实体: `breaker_A_entity`, `breaker_B_entity`, `breaker_C_entity`。
*   定义的拓扑结构是： 电源 -> **线路A** (出口断路器A) -> **线路B** (出口断路器B) -> **线路C** (出口断路器C)。线路C是末端线路。

### 2. `LineIdentityComponent` (线路标识组件) 的核心作用

这是表示和存储线路拓扑连接的关键组件。每个线路实体都会附加一个 `LineIdentityComponent`。其主要成员包括：

*   `std::string name`: 线路的名称 (例如 "线路A", "线路B", "线路C")。
*   `std::optional<Entity> upstream_line_entity`: 指向上游线路实体的ID。对于最上游的线路 (本例中的线路A，其上游是电源)，此项为 `std::nullopt`。
*   `std::optional<Entity> downstream_line_entity`: 指向下游线路实体的ID。对于最下游的线路 (本例中的线路C)，此项为 `std::nullopt`。
*   `Entity associated_breaker_entity`: 与此线路关联的、用于隔离此线路故障的断路器实体ID。通常是线路的出口断路器。

### 3. 初始化过程中的拓扑链接

拓扑连接是通过在创建 `LineIdentityComponent` 时设置 `downstream_line_entity`，然后反向更新下游线路的 `upstream_line_entity` 来实现的。

*   **线路C (最下游):**
    *   `downstream_line_entity` 和 `upstream_line_entity` 初始时都为 `std::nullopt` (因为没有更下游的，上游连接后续由B线路指定)。
    *   `registry_.emplace<LineIdentityComponent>(line_C_entity, "线路C", breaker_C_entity, std::nullopt, std::nullopt);`

*   **线路B:**
    *   创建时指定其下游为 `line_C_entity`:
        `registry_.emplace<LineIdentityComponent>(line_B_entity, "线路B", breaker_B_entity, std::nullopt, line_C_entity);`
    *   然后更新线路C的 `LineIdentityComponent`，将其 `upstream_line_entity` 设置为 `line_B_entity`:
        `registry_.get<LineIdentityComponent>(line_C_entity)->upstream_line_entity = line_B_entity;`

*   **线路A (最上游):**
    *   创建时指定其下游为 `line_B_entity`:
        `registry_.emplace<LineIdentityComponent>(line_A_entity, "线路A", breaker_A_entity, std::nullopt, line_B_entity);`
    *   然后更新线路B的 `LineIdentityComponent`，将其 `upstream_line_entity` 设置为 `line_A_entity`:
        `registry_.get<LineIdentityComponent>(line_B_entity)->upstream_line_entity = line_A_entity;`

通过这种方式，`upstream_line_entity` 和 `downstream_line_entity` 形成了一个双向链表（逻辑上的），清晰地定义了线路间的串联关系。

### 4. `BreakerIdentityComponent` (断路器标识组件)

*   `std::string name`: 断路器名称。
*   `Entity line_entity_it_isolates`: 此断路器主要负责隔离的线路实体ID。在初始化时，会设置此值，例如 `breaker_A_entity` 隔离 `line_A_entity`。
*   `bool is_stuck_on_trip_cmd`: 标记此断路器在收到跳闸命令时是否会拒动。在示例中，`breaker_C_entity` 被设置为拒动 (`true`)。

### 5. `BreakerStateComponent` (断路器状态组件)

*   `bool is_open`: 表示断路器的当前状态。`true` 为打开 (分闸)，`false` 为闭合 (合闸)。所有断路器初始时都为闭合状态。

## 拓扑程序的工作原理 (如何利用拓扑信息)

电力系统拓扑信息主要在保护装置的逻辑协程 (`protection_device_logic_task`) 中，通过以下两个核心的辅助函数被查询和利用：

### 1. `bool LogicProtectionSystem::is_line_downstream_or_same(Entity current_line_entity, Entity target_line_entity)`

*   **目的:**
    判断 `target_line_entity` (通常是发生故障的线路) 是否是 `current_line_entity` (通常是保护装置安装位置的线路) 本身，或者是其下游的任一线路。
*   **工作原理:**
    1.  从 `current_line_entity` 开始作为路径追踪的起点。
    2.  **循环检查：**
        a.  如果当前追踪的线路 (`path_tracer_entity`) 等于 `target_line_entity`，则目标找到，返回 `true`。
        b.  获取当前追踪线路的 `LineIdentityComponent`。
        c.  检查其 `downstream_line_entity`。
        d.  如果存在下游线路 (即 `downstream_line_entity.has_value()` 为 `true`)，则将路径追踪点更新为其下游线路 (`path_tracer_entity = line_id_comp->downstream_line_entity.value()`)，然后继续下一次循环。
        e.  如果不存在下游线路 (到达路径末端)，但仍未找到 `target_line_entity`，则说明目标不在此路径下游，返回 `false`。
    3.  包含一个安全计数器 (`safety_count`) 防止因拓扑配置错误或环路导致的无限循环。
*   **用途:**
    主要用于**后备保护**判断其保护范围。例如，线路A的后备保护，其配置的 `protected_line_entity` 是线路A。当故障发生在下游的线路B或线路C时，此函数会返回 `true`，表明故障在线路A的保护范围（其自身或其下游）之内。

### 2. `bool LogicProtectionSystem::is_fault_path_energized(Entity perspective_line_entity, Entity fault_on_line_entity)`

*   **目的:**
    从 `perspective_line_entity` (通常是保护装置安装位置的线路，即“视角”线路) 开始，判断到达 `fault_on_line_entity` (实际发生故障的线路) 的电气路径是否仍然带电。路径带电意味着从视角线路到故障线路之间的所有串联断路器（包括故障线路自身的出口断路器，如果视角线路就是故障线路的话）都是闭合的。
*   **工作原理:**
    1.  初始化当前评估线路 `current_eval_line = perspective_line_entity`。
    2.  **向下游迭代追踪，直至到达 `fault_on_line_entity`：**
        a.  对于当前评估线路 `current_eval_line` (如果它不是 `fault_on_line_entity` 本身)：
            i.  获取其 `LineIdentityComponent`。
            ii. 找到其关联的出口断路器 `associated_breaker_entity`。
            iii.获取该断路器的 `BreakerStateComponent`。
            iv. 如果该断路器的 `is_open` 状态为 `true` (已打开)，则说明从视角点到故障点的路径在此处已经被断开（去能）。函数立即返回 `false` (路径不带电)。
        b.  如果当前评估线路的出口断路器是闭合的，并且它有下游线路，则将 `current_eval_line` 更新为其下游线路，继续迭代。
    3.  **当 `current_eval_line` 等于 `fault_on_line_entity` (已到达故障线路本身)：**
        a.  获取故障线路 `fault_on_line_entity` 的 `LineIdentityComponent`。
        b.  找到其关联的出口断路器 `associated_breaker_entity`。
        c.  获取该断路器的 `BreakerStateComponent`。
        d.  如果该断路器的 `is_open` 状态为 `true`，则说明故障已被其自身的出口断路器隔离。函数返回 `false` (路径不带电，因为故障点本身已被有效隔离)。
    4.  如果在整个追踪过程中，所有检查到的相关断路器都处于闭合状态，则函数最终返回 `true` (路径带电)。
    5.  包含安全计数器和对组件缺失的保守处理 (如果组件信息缺失，通常假设断路器闭合/路径带电，以确保保护能启动)。
*   **用途:**
    *   **后备保护的关键判据：** 后备保护在通过 `is_line_downstream_or_same` 确认故障在其范围内后，会调用此函数。如果 `is_fault_path_energized` 返回 `false`（例如，因为下游主保护或更靠近故障点的其他后备保护已经动作并切除了故障），则此后备保护不应再动作，会进入复归状态。
    *   **保护动作前的最终校验：** 任何保护装置（主保护或后备保护）在内部的跳闸延时计时结束后，准备向其控制的断路器发送跳闸命令之前，会再次调用此函数。如果在计时期间，故障已经被其他保护装置成功清除（即 `is_fault_path_energized` 返回 `false`），则该保护装置会放弃发送跳闸命令并转入复归状态，避免不必要的越级跳闸。

## 在 `protection_device_logic_task` 中的应用示例

以**线路C发生永久性故障，且断路器C拒动**的场景为例，说明拓扑信息如何被后备保护（如线路B的后备保护）利用：

1.  **故障注入 (T=1000ms):**
    *   `scheduler_.trigger_event(LOGIC_FAULT_EVENT, LogicFaultInfo { line_C_entity });`

2.  **线路C主保护 (`prot_main_C_entity`) 响应:**
    *   `type` 为 `MAIN`, `protected_line_entity` 为 `line_C_entity`。
    *   故障线路 (`fault_info.faulted_line_entity`) 与其 `protected_line_entity` 相同，判定为相关故障。
    *   进入 `PICKED_UP` 状态，然后 `TRIPPING_TIMER_RUNNING` (延时50ms)。
    *   **T=1050ms (计时结束):**
        *   调用 `is_fault_path_energized(prot_main_C_entity->protected_line_entity, fault_info.faulted_line_entity)` 即 `is_fault_path_energized(line_C_entity, line_C_entity)`。
        *   检查 `breaker_C_entity` 状态，此时为闭合。返回 `true`。
        *   发送跳闸命令给 `breaker_C_entity` (`scheduler_.trigger_event(LOGIC_BREAKER_TRIP_COMMAND_EVENT, ...)`).
        *   `prot_main_C_entity` 进入 `TRIPPED` 状态。

3.  **断路器C (`breaker_C_entity`) 逻辑响应:**
    *   `breaker_logic_task(breaker_C_entity)` 协程被唤醒。
    *   检测到 `cmd.breaker_to_trip_entity == breaker_C_entity`。
    *   但其 `BreakerIdentityComponent->is_stuck_on_trip_cmd` 为 `true`。
    *   记录日志“发生拒动”，`BreakerStateComponent->is_open` **保持为 `false`** (闭合)。不触发 `LOGIC_BREAKER_STATUS_CHANGED_EVENT` (至少不是变为打开状态的事件)。

4.  **线路B后备保护 (`prot_backup_B_entity`) 响应 (与C主保护并行启动，但延时更长):**
    *   `type` 为 `BACKUP`, `protected_line_entity` 为 `line_B_entity`。
    *   收到 `LOGIC_FAULT_EVENT` (故障在 `line_C_entity`)。
    *   调用 `is_line_downstream_or_same(line_B_entity, line_C_entity)`。由于线路C是线路B的下游，返回 `true`。
    *   调用 `is_fault_path_energized(line_B_entity, line_C_entity)`:
        *   检查 `breaker_B_entity` (线路B出口断路器) 状态，闭合。
        *   追踪到下游 `line_C_entity`。检查 `breaker_C_entity` (线路C出口断路器) 状态，仍然闭合（因为拒动）。
        *   返回 `true` (路径带电)。
    *   线路B后备保护判定为相关故障，进入 `PICKED_UP` 状态，然后 `TRIPPING_TIMER_RUNNING` (延时2000ms)。

5.  **线路B后备保护计时结束 (T = 1000ms (故障) + 2000ms (延时) = 3000ms):**
    *   再次调用 `is_fault_path_energized(line_B_entity, line_C_entity)` 校验故障是否仍然存在且路径带电。
    *   由于断路器C拒动，故障未被清除，路径上的断路器B和C（从B的视角看过去）仍然是闭合的。该函数返回 `true`。
    *   线路B后备保护确认需要动作，向 `breaker_B_entity` 发送跳闸命令。
    *   `prot_backup_B_entity` 进入 `TRIPPED` 状态。

6.  **断路器B (`breaker_B_entity`) 逻辑响应:**
    *   `breaker_logic_task(breaker_B_entity)` 协程被唤醒。
    *   `is_stuck_on_trip_cmd` 为 `false` (不拒动)。
    *   模拟延时20ms后，`BreakerStateComponent->is_open` 设置为 `true`。
    *   触发 `LOGIC_BREAKER_STATUS_CHANGED_EVENT`，通告 `breaker_B_entity` 已打开。
    *   此时，故障在线路C上，但被上游的断路器B切除。

7.  **线路A后备保护 (`prot_backup_A_entity`) 的行为 (假设其延时3000ms):**
    *   与线路B后备保护类似，它也会启动计时，因为C在其下游且路径最初带电。
    *   **计时结束 (T = 1000ms + 3000ms = 4000ms):**
        *   再次调用 `is_fault_path_energized(line_A_entity, line_C_entity)`。
        *   检查 `breaker_A_entity` 状态，闭合。
        *   追踪到下游 `line_B_entity`。检查 `breaker_B_entity` 状态。**此时 `breaker_B_entity` 已经是打开状态了** (在T=3020ms左右打开的)。
        *   因此，`is_fault_path_energized` 函数会因为在路径上遇到打开的断路器B而返回 `false` (路径已不带电)。
    *   线路A的后备保护检测到故障已被其他装置（断路器B）清除，于是它会进入 `RESETTING` 状态，**不会**向 `breaker_A_entity` 发送跳闸命令。

## 总结

该程序通过 `LineIdentityComponent` 中的 `upstream_line_entity` 和 `downstream_line_entity` 成员，以及线路与 `associated_breaker_entity` 的关联，在ECS框架中显式地构建了串联线路的拓扑模型。

核心的拓扑检查函数 `is_line_downstream_or_same` 和 `is_fault_path_energized` 结合断路器的实时状态 (`BreakerStateComponent`)，使得保护装置（尤其是后备保护）能够：

1.  **准确判断保护范围：** 确定一个远方故障是否属于其管辖。
2.  **实现保护配合：** 在发出跳闸命令前，校验故障是否已被其他保护装置清除，从而避免不必要的越级跳闸或扩大停电范围。

这种基于显式拓扑信息和状态检查的机制，是实现复杂继电保护逻辑仿真的关键，能够有效地模拟主保护、后备保护以及断路器拒动等场景下的系统行为。