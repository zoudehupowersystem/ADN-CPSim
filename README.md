# 主动配电网CPS统一行为建模与高效仿真平台

## 1. 项目概述

ADN-CPSim(Active Distribution Network Cyber-Physical Simulation) 是一个基于C++20开发的高性能仿真平台，旨在为主动配电网 (Active Distribution Network, ADN) 中日益复杂和多样化的信息物理系统 (Cyber-Physical System, CPS) 应用提供统一的行为建模与高效的事件驱动仿真环境。**本项目当前主要作为学术研究的简化测试版本，用于验证所提出的建模与仿真方法的可行性与高效性。**

随着分布式能源、储能、电动汽车以及各类智能感知与控制装置在配电网中的广泛应用，传统的电力系统仿真工具在统一描述这些跨物理层与信息层、行为异构的业务，并高效处理其复杂的交互逻辑方面面临挑战。本项目提出的分层实体-组件-系统 (Hierarchical Entity-Component-System, HECS) 架构与基于C++20协程的事件驱动仿真引擎，致力于解决这些难题。

**目标用户：** 电力系统工程师、研究人员、从事主动配电网、微电网、虚拟电厂 (VPP)、CPS建模与仿真相关工作的开发者，**尤其适合对新型仿真技术进行学术探索与验证的场景。**

## 2. 项目特点与创新

*   **统一的行为建模框架 (ECS)**：
    *   **分层解耦**：通过实体（Entity）、组件（Component）和系统（System，由协程任务实现）三个层次，清晰地描述了物理设备（如IED、DTU、充电桩、储能单元）和信息系统应用（如VPP控制逻辑、馈线自动化主站）的行为。
    *   **行为等效性**：组件模型遵循行为等效原则，关注设备或应用在特定业务场景下的外部行为特性和交互逻辑，而非精确复刻其内部复杂机理，显著降低了模型复杂度，提高了建模效率和通用性。
    *   **模块化与可扩展性**：新的设备类型或CPS应用可以通过定义新的行为组件轻松集成到仿真平台中，具有良好的可扩展性。

*   **基于C++20协程的高效事件驱动仿真引擎**：
    *   **轻量级并发**：利用C++20协程实现用户态的轻量级并发，能够以极低的开销管理成千上万个并发执行的仿真对象（如每个充电桩的行为逻辑）。
    *   **事件驱动核心**：仿真过程由离散事件驱动，仅当关键事件发生（如频率更新、故障注入）或特定条件满足（如VPP控制逻辑中的频率偏差阈值、时间阈值）时，才触发相关对象的行为计算与状态更新，大幅减少了不必要的计算，提高了仿真效率。
    *   **异步逻辑的同步化表达**：通过 `co_await` 关键字，复杂的异步等待（如延时、等待外部事件）可以用同步的方式清晰表达，显著提升了代码的可读性和可维护性。
    *   **多时间尺度支持**：能够自然地处理保护（毫秒级）、控制（秒/毫秒级）、调度（分钟/小时级）等不同时间尺度和响应频率的CPS应用。
    *   **实时与非实时仿真模式**：平台内置了标准事件调度器 (`Scheduler`) 用于非实时仿真（尽可能快地执行），以及实时调度器 (`RealTimeScheduler`)，可尝试将仿真时间的推进与物理时钟同步，适用于需要与真实时间对齐的测试场景。

*   **高性能日志记录**：
    *   集成 `spdlog` 库，提供高性能、异步的日志记录功能，支持将详细的仿真数据在程序结束时统一写入文件（如CSV格式），减少了仿真过程中的I/O瓶颈。

## 3. 关键技术栈

*   **编程语言**: C++20 (充分利用其协程、模板、并发等新特性)
*   **核心设计模式**:
    *   实体-组件-系统 (ECS) 架构 (本项目中体现为HECS)
    *   事件驱动架构 (Event-Driven Architecture, EDA)
*   **并发模型**: C++20 Coroutines
*   **日志库**: [spdlog](https://github.com/gabime/spdlog)
*   **构建系统**: CMake

## 4. 已实现功能与仿真案例介绍

本项目当前已实现并演示了以下核心功能和应用场景（**作为简化测试版本，部分功能为原理性演示**）：

### 4.1 基础仿真引擎 (`cps_coro_lib.h`, `ecs_core.h`)

*   基于协程的离散事件调度器，支持非实时 (`Scheduler`) 和实时 (`RealTimeScheduler`) 模式。
*   协程任务 (`Task`) 的封装与生命周期管理。
*   基于时间的挂起 (`cps_coro::delay`) 和基于事件的等待 (`cps_coro::wait_for_event`) 机制。
*   实体 (`Entity`) 与行为组件 (`IComponent`) 的注册、存储和管理 (`Registry`)。

### 4.2 仿真案例一：自动电压控制 (AVC) 场景 (非实时与实时模式)

*   **文件**: `avc_simulation.cpp`
*   **目标**: 演示平台在模拟包含传感器、控制器和监测器等多智能体交互的复杂CPS应用场景的能力，并对比非实时与实时仿真模式。
*   **场景描述**:
    *   **传感器协程 (`sensor_coroutine_complex_avc`)**: 模拟一个传感器网络，按预设时序发布电网电压和负荷的变化事件（`VOLTAGE_CHANGE_EVENT_AVC`, `LOAD_CHANGE_EVENT_AVC`）。事件数据包括电压值、负荷值、母线标识和时间戳。
    *   **AVC控制器协程 (`avc_coroutine_complex_avc`)**: 模拟一个自动电压控制器，它监听电压变化事件。根据接收到的电压值和预设的控制逻辑（如欠压/过压阈值），输出相应的控制建议或动作（例如，投入/切除电容器组、调整变压器分接头）。控制器具有一定的响应延迟。
    *   **负荷监测器协程 (`load_monitor_coroutine_avc`)**: 模拟一个负荷监测单元，它监听负荷变化事件，并根据负荷水平记录信息或发出告警。
*   **核心机制演示**:
    *   **多协程协作**: 三个协程通过事件进行交互，共同完成一个动态的控制与监测过程。
    *   **事件驱动**: 各协程的行为由特定事件触发。
    *   **带数据的事件传递**: 电压和负荷事件都携带了具体的数据结构 (`VoltageDataAvc`, `LoadDataAvc`)。
    *   **实时/非实时对比**: 该案例同时提供了非实时 (`avc_test_non_realtime`) 和实时 (`avc_test_realtime`) 的启动函数，用于展示和对比两种调度模式下的仿真行为和执行时间特性。输出直接打印到控制台。

### 4.3 仿真案例二：虚拟电厂 (VPP) 频率响应 (事件驱动优化)

*   **文件**: `frequency_system.*`, `vpp_system.cpp.cpp` (VPP初始化与任务启动部分)
*   **目标**: 模拟大规模分布式资源（EV充电桩、储能单元）聚合为虚拟电厂，参与电网一次频率调节，并重点展示事件驱动优化在VPP控制逻辑中的应用。
*   **场景描述**:
    *   **资源建模**:
        *   创建了大量电动汽车充电桩 (EVCS) 和分布式储能单元 (ESS) 实体。
        *   每个资源实体拥有 `PhysicalStateComponent` (存储当前功率、SOC) 和 `FrequencyControlConfigComponent` (存储设备类型、基准功率、调频增益、死区、功率上下限、SOC约束等)。
    *   **频率预言机 (`frequencyOracleTask`)**: 模拟一个频率测量源，根据预设的扰动模型和时间步长，周期性地计算系统频率偏差，并触发 `FREQUENCY_UPDATE_EVENT` 事件，广播频率信息。
    *   **VPP控制协程 (`vppFrequencyResponseTask`)**:
        *   代表一个VPP（例如，一个EV VPP和一个ESS VPP可以分别实例化此任务）。
        *   监听 `FREQUENCY_UPDATE_EVENT` 事件。
        *   **事件驱动优化**：仅当接收到的频率偏差与上次VPP内部状态更新时的频率偏差差异超过阈值（`FREQUENCY_CHANGE_THRESHOLD_HZ`），或者距离上次更新的时间超过阈值（`TIME_THRESHOLD_SECONDS`）时，才对VPP内所有管理的资源进行详细的状态更新（SOC演变计算）和目标功率重计算。这种机制避免了在频率变化不显著或时间间隔过短时进行不必要的计算，显著提高了大规模VPP仿真的效率。
        *   根据每个资源的配置参数、当前SOC和接收到的频率偏差，计算其应提供的调频功率。
*   **核心机制演示**:
    *   **ECS应用**: 大量异构资源通过统一的组件接口进行管理和配置。
    *   **大规模轻量级并发**: 虽然未直接为每个资源创建独立协程（VPP协程统一处理），但ECS结构和事件驱动机制为未来扩展到更细粒度的并发控制（如每个资源一个协程）奠定了基础。
    *   **优化控制逻辑**: 事件驱动的VPP控制逻辑是此案例的核心亮点，展示了如何通过智能调度减少计算量。
    *   **数据记录**: 仿真过程中的关键数据（仿真时间、频率偏差、VPP总功率等）被记录到CSV文件 (`虚拟电厂频率响应数据.csv`)，便于后续分析。

### 4.4 仿真案例三：逻辑保护仿真

*   **文件**: `logic_protection_system.h`, `logic_protection_system.cpp`, 以及 `main.cpp` 中相关的初始化与任务启动部分。
*   **目标**: 演示平台在模拟电力系统继电保护基本逻辑、信息物理交互、以及复杂故障场景（如断路器拒动、后备保护配合）下的行为。**此案例重点关注保护的逻辑行为和时序配合，不涉及详细的电气定值计算和短路电流分析。**
*   **场景描述**:
    *   **拓扑与设备建模**:
        *   模拟一个包含三条串联线路（A、B、C，A为上游，C为下游）的简化配电网拓扑。
        *   每条线路配置一个关联的断路器实体。断路器具有状态（开/合）和可选的拒动属性（例如，线路C的断路器被设置为在收到跳闸命令时会拒动）。
        *   每条线路均配置主保护和后备保护装置实体（线路C仅配置主保护作为示例）。
    *   **组件建模**:
        *   **`LineIdentityComponent`**: 存储线路名称、上下游连接关系及关联断路器。
        *   **`BreakerIdentityComponent`**: 存储断路器名称、其隔离的线路以及是否拒动。
        *   **`BreakerStateComponent`**: 存储断路器的当前开断状态。
        *   **`ProtectionDeviceComponent`**: 存储保护装置名称、类型（主/后备）、监视的线路、控制的断路器、动作延时以及内部运行状态（如空闲、启动、计时、跳闸、复归）。
    *   **核心逻辑协程**:
        *   **`LogicProtectionSystem::breaker_logic_task`**: 每个断路器实体运行一个此协程。它等待 `LOGIC_BREAKER_TRIP_COMMAND_EVENT` 事件。收到针对自身的命令后，根据是否拒动来决定是否改变状态（模拟操作延时后打开），并触发 `LOGIC_BREAKER_STATUS_CHANGED_EVENT`。
        *   **`LogicProtectionSystem::protection_device_logic_task`**: 每个保护装置实体运行一个此协程。它等待 `LOGIC_FAULT_EVENT` 事件。
            *   **故障判断**: 收到故障事件后，根据保护类型（主/后备）和预设逻辑（主保护关心本线路故障；后备保护关心本线路及下游线路故障且故障路径仍带电）判断故障是否相关。
            *   **拓扑感知**: 保护逻辑依赖 `is_line_downstream_or_same` 和 `is_fault_path_energized` 辅助函数进行拓扑分析，判断故障位置和路径是否带电（即路径上是否有已打开的断路器）。
            *   **延时与出口**: 若故障相关，则进入计时状态，延时后若故障依然存在（路径仍带电），则向其控制的断路器发送跳闸命令。
            *   **复归逻辑**: 若在计时期间或计时结束后发现故障已被其他保护清除（路径去能），则保护装置复归。
    *   **仿真场景 (`LogicProtectionSystem::simulate_permanent_fault_with_breaker_failure_scenario`)**:
        *   在预设时间点向最下游的线路C注入一个永久性单相接地故障（通过触发 `LOGIC_FAULT_EVENT`）。
        *   **预期序列**:
            1.  C线路主保护检测到故障，启动并延时出口，向C线路断路器发送跳闸命令。
            2.  C线路断路器拒动，故障未被切除。
            3.  B线路后备保护和A线路后备保护检测到故障（因C主保护失效），均启动并开始各自的延时计时（B的延时小于A）。
            4.  B线路后备保护延时先到，出口并向B线路断路器发送跳闸命令。
            5.  B线路断路器正常动作，分闸，成功从B侧隔离故障。
            6.  A线路后备保护在其延时到达后，通过拓扑检查发现故障已被B断路器隔离（故障路径已去能），因此复归，不发出跳闸命令。
*   **核心机制演示**:
    *   **详细的保护逻辑与时序**: 模拟了主保护、后备保护的启动、延时、出口、拒动及配合复归过程。
    *   **信息物理交互的闭环**: 故障（物理扰动）-> 保护检测（信息感知）-> 逻辑判断与延时（信息处理）-> 跳闸命令（控制决策）-> 断路器动作/拒动（物理执行）-> 拓扑状态改变 -> 影响后续保护判断。
    *   **事件驱动的复杂交互**: 多个保护装置和断路器通过事件（故障、跳闸命令、状态变更）进行异步交互和协调。
    *   **拓扑依赖性**: 保护的行为（特别是后备保护的启动和复归）依赖于简化的实时拓扑状态判断。
    *   **模块化与可配置性**: 线路、断路器、保护的参数（如延时、拒动行为）均可通过组件配置。

### 4.5 仿真统计与结果输出

*   在 `main.cpp` 中，仿真结束后会统计并输出仿真的**真实物理执行时间**和**峰值内存占用**（通过平台相关的API获取），用于评估仿真平台的性能。

## 5. 如何构建与运行

### 依赖

*   C++20 兼容的编译器 (推荐 GCC 10+ 或 Clang 12+)
*   CMake (3.20 或更高版本)
*   `spdlog` 库:
    *   **Ubuntu/Debian**: `sudo apt install libspdlog-dev`
    *   **其他系统或源码安装**: 请参考 `spdlog` 官方文档。
*   `pthread` (通常在Linux系统中已具备)

### 构建步骤 (以Linux为例)

1.  克隆项目 (如果从Git仓库获取):
    ```bash
    git clone <你的项目仓库URL>
    cd <项目目录>
    ```
2.  创建构建目录并进入:
    ```bash
    mkdir build
    cd build
    ```
3.  运行 CMake (指定构建类型，如Release以获得优化性能):
    ```bash
    # 如果 spdlog 是通过系统包管理器 (如 apt) 安装的，CMake 通常能自动找到它
    cmake -DCMAKE_BUILD_TYPE=Release ..
    
    # 如果 spdlog 头文件和库位于非标准路径，你可能需要设置 CMAKE_PREFIX_PATH
    # 或者在 CMakeLists.txt 中调整查找逻辑。
    ```
4.  编译项目:
    ```bash
    make -j$(nproc) # 使用所有可用的CPU核心并行编译
    ```
5.  运行可执行文件:
    可执行文件通常生成在 `build/` 目录下（或 `build/bin/`，取决于CMake配置）。
    假设可执行文件名为 `adn_cpsim`:
    ```bash
    ./adn_cpsim
    ```

请参考项目根目录下的 `CMakeLists.txt` 文件获取详细的构建配置信息。

## 6. 预期应用与未来展望

*   **主动配电网规划与运行分析**：评估不同控制策略、VPP配置、保护方案在复杂扰动下的性能。
*   **CPS算法验证与优化**：为新的分布式控制、优化调度、故障诊断与自愈等算法提供高效的仿真验证平台。
*   **教育与研究**：作为学习和研究电力系统CPS建模、事件驱动仿真、C++协程应用的实例。

未来工作可能包括：
*   扩展更丰富的电力设备模型库（如光伏、风机、详细的变压器和线路模型）和CPS应用模型库（如馈线自动化逻辑、微网能量管理）。
*   集成简易的电网潮流计算或动态仿真核心，以提供更精确的物理背景。
*   增强图形化界面和结果可视化功能。
*   支持与外部系统（如实时数字仿真器RTDS/OPAL-RT、SCADA系统原型）通过标准接口（如FMI、HLA、OPC UA）进行联合仿真。
*   进一步优化大规模系统仿真的性能，例如探索分布式仿真。

## 7. 贡献与许可证

欢迎对本项目进行改进和贡献！如果您有任何问题或建议，请通过Issue提出。

本项目旨在促进学术交流与技术验证，采用宽松的MIT许可证。这意味着您可以自由地使用、复制、修改、合并、出版发行、散布、再授权及贩售软件及软件的副本，惟须遵守下列条件：**不得侵犯作者原创权利，不得申请专利、软件著作权；学术研究使用需要在参考文献中列出本项目。否则将依法追究法律责任**。
